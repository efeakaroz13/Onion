!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
Accept	util/socket.cpp	/^bool ListenSocket::Accept(Socket *socket, EndPoint &endpoint, bool restart)$/;"	f	class:Onion::util::ListenSocket
Address	util/ip_address.hpp	/^		const std::vector<uint8_t>& Address() const { return address_; }$/;"	f	class:Onion::util::IPAddress
Address	util/ip_address.hpp	/^		std::vector<uint8_t>& Address() { return address_; }$/;"	f	class:Onion::util::IPAddress
Bind	util/socket.cpp	/^bool Socket::Bind(const EndPoint &endpoint)$/;"	f	class:Onion::util::Socket
CPP	Makefile	/^CPP 		 = g++$/;"	m
CPPFLAGS	Makefile	/^CPPFLAGS = -std=c++11 -Wall -O$/;"	m
Clear	util/ip_address.hpp	/^		void Clear() { address_.clear(); }$/;"	f	class:Onion::util::IPAddress
Close	util/socket.cpp	/^bool Socket::Close()$/;"	f	class:Onion::util::Socket
Connect	util/socket.cpp	/^bool DataSocket::Connect(const EndPoint &endpoint)$/;"	f	class:Onion::util::DataSocket
Create	util/socket.hpp	/^		bool Create() { return Socket::Create(AF_INET, SOCK_STREAM, 0); }$/;"	f	class:Onion::util::ListenSocket
Create	util/socket.hpp	/^		bool Create(int domain, int type, int protocol) {$/;"	f	class:Onion::util::Socket
DIR	Makefile	/^DIR=util$/;"	m
DataSocket	util/socket.hpp	/^class DataSocket : public Socket$/;"	c	namespace:Onion::util
EndPoint	util/end_point.hpp	/^		EndPoint(const IPAddress &address, uint16_t port):address_(address), port_(port) { }$/;"	f	class:Onion::util::EndPoint
EndPoint	util/end_point.hpp	/^class EndPoint$/;"	c	namespace:Onion::util
Family	util/ip_address.cpp	/^int IPAddress::Family() const$/;"	f	class:Onion::util::IPAddress
IPAddress	util/ip_address.cpp	/^IPAddress::IPAddress(const char *address)$/;"	f	class:Onion::util::IPAddress
IPAddress	util/ip_address.hpp	/^class IPAddress$/;"	c	namespace:Onion::util
IPv4	util/ip_address.hpp	/^		static const int IPv4 = 4;$/;"	m	class:Onion::util::IPAddress
IsValid	util/socket.hpp	/^		bool IsValid() const { return fd_ != -1; }$/;"	f	class:Onion::util::Socket
Listen	util/socket.hpp	/^		bool Listen(int backlog = 1024) { return listen(fd(), backlog) == 0; }$/;"	f	class:Onion::util::ListenSocket
ListenSocket	util/socket.hpp	/^class ListenSocket : public Socket$/;"	c	namespace:Onion::util
OBJ	Makefile	/^OBJ=util\/ip_address.o util\/end_point.o util\/socket.o$/;"	m
Onion	util/end_point.cpp	/^namespace Onion {$/;"	n	file:
Onion	util/end_point.hpp	/^namespace Onion {$/;"	n
Onion	util/ip_address.cpp	/^namespace Onion {$/;"	n	file:
Onion	util/ip_address.hpp	/^namespace Onion {$/;"	n
Onion	util/socket.cpp	/^namespace Onion {$/;"	n	file:
Onion	util/socket.hpp	/^namespace Onion {$/;"	n
Onion	util/string_op.cpp	/^namespace Onion {$/;"	n	file:
Onion	util/string_op.hpp	/^namespace Onion {$/;"	n
Resize	util/ip_address.hpp	/^		void Resize(size_t size) { address_.resize(size); }$/;"	f	class:Onion::util::IPAddress
SetAddressFrom	util/end_point.cpp	/^bool EndPoint::SetAddressFrom(const struct sockaddr &sockaddr, const socklen_t len)$/;"	f	class:Onion::util::EndPoint
SetAddressTo	util/end_point.cpp	/^bool EndPoint::SetAddressTo(struct sockaddr &sockaddr, socklen_t &len) const$/;"	f	class:Onion::util::EndPoint
SetFd	util/socket.cpp	/^void Socket::SetFd(int fd)$/;"	f	class:Onion::util::Socket
Socket	util/socket.hpp	/^		Socket():fd_(-1) { }$/;"	f	class:Onion::util::Socket
Socket	util/socket.hpp	/^class Socket$/;"	c	namespace:Onion::util
SplitByChar	util/string_op.cpp	/^std::vector<std::string> StringOperation::SplitByChar(const std::string &str, const char c)$/;"	f	class:Onion::util::StringOperation
StringOperation	util/string_op.hpp	/^class StringOperation$/;"	c	namespace:Onion::util
TcpSocket	util/socket.hpp	/^class TcpSocket : public DataSocket$/;"	c	namespace:Onion::util
_ENDPOINT_HPP_	util/end_point.hpp	11;"	d
_IPADDRESS_HPP_	util/ip_address.hpp	11;"	d
_SOCKET_HPP_	util/socket.hpp	11;"	d
_STRINGOP_HPP_	util/string_op.hpp	11;"	d
address_	util/end_point.hpp	/^		IPAddress  address_;$/;"	m	class:Onion::util::EndPoint
address_	util/ip_address.hpp	/^		std::vector<uint8_t> address_;$/;"	m	class:Onion::util::IPAddress
fd	util/socket.hpp	/^		int fd() const { return fd_; }$/;"	f	class:Onion::util::Socket
fd_	util/socket.hpp	/^		int fd_;$/;"	m	class:Onion::util::Socket
main	Onion.cpp	/^int main(int argc, char **argv)$/;"	f
port_	util/end_point.hpp	/^		uint16_t   port_;$/;"	m	class:Onion::util::EndPoint
util	util/end_point.cpp	/^namespace util {$/;"	n	namespace:Onion	file:
util	util/end_point.hpp	/^namespace util {$/;"	n	namespace:Onion
util	util/ip_address.cpp	/^namespace util {$/;"	n	namespace:Onion	file:
util	util/ip_address.hpp	/^namespace util {$/;"	n	namespace:Onion
util	util/socket.cpp	/^namespace util {$/;"	n	namespace:Onion	file:
util	util/socket.hpp	/^namespace util {$/;"	n	namespace:Onion
util	util/string_op.cpp	/^namespace util {$/;"	n	namespace:Onion	file:
util	util/string_op.hpp	/^namespace util {$/;"	n	namespace:Onion
~Socket	util/socket.hpp	/^		virtual ~Socket() { };$/;"	f	class:Onion::util::Socket
